import collections
import functools
import itertools
import re
import sys
import types
import copy
import visionexceptions
import time

# Selenium libraries
# Try local first, fallback to one dir above
try:
    import selenium
    from selenium.common.exceptions import (
        WebDriverException,
        ElementNotVisibleException,
        StaleElementReferenceException,
        NoSuchFrameException,
        TimeoutException,
        NoAlertPresentException,
        UnexpectedAlertPresentException )
    from selenium.webdriver.support.ui import WebDriverWait
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(__file__),'..'))
    import selenium
    from selenium.common.exceptions import (
        WebDriverException,
        ElementNotVisibleException,
        StaleElementReferenceException,
        NoSuchFrameException,
        TimeoutException,
        NoAlertPresentException,
        UnexpectedAlertPresentException )
    from selenium.webdriver.support.ui import WebDriverWait

"""
Vision Parser

Anything here is focused on parsing the stream of tokens according to
the following grammar:

Command ScopeIndicator* ((Verb|Noun|Context|Variable) (Literal)?)+

The following rules apply:
    1)  There must be one and only one Verb per Command.
    2)  While input-specific grammars are possible, the tokens that
        implement them should be defined in the scanner module, NOT
        HERE.  These tokens need to make sure that by the time they
        are done, the stream matches the above grammar as far as they
        are responsible.
    3)  This grammar does NOT care how Verbs, Nouns, Contexts, and
        Variables are interleaved, but any Literal to be associated
        with one of the above must follow it, and the ordering of
        different kinds of object is significant.  For example the
        following groups of tokens are sementically identical:

            Command Verb 'a' Noun 'b' Noun 'c' Context 'd' Variable 'e'
            Command Variable 'e' Context 'd' Noun 'b' Noun 'c' Verb 'a'

        But the following two would not.

            Command Verb 'a' Noun 'b' Noun 'c' Context 'd' Variable 'e'
            Command Verb 'a' Noun 'c' Noun 'd' Context 'd' Variable 'e'

    4)  Each Command MUST have exactly one Verb from the scanner.
    5)  Before the Command is given to the compiler, it will have
        exactly ONE Context, and Commands that have Tests will also have
        exactly ONE Variable.  If these are not recieved from the
        scanner, suitable defaults will be inserted by the parser

If used as an iterator the VisionParser will return one Command each
iteration.

NOTHING here should be specific to the syntax implemented by the
scanner.
NOTHING here should be specific to the output generated by the compiler.

The parts of this interface dealing with compilation are intended to be
monkeypatched from the compiler interface.

This needs to have more support for various kinds of errors, so that I
can provide useful messages to those that are writing tests, rather than
letting Python spew at them.
"""

def get_subclasses(cl, found=None):
    yield cl
    found = found or set(cl.__subclasses__())
    for sub in found:
        yield sub
        found.update(sub.__subclasses__())

class Typed(object):
    def __init__(self, identifier, token_type=None):
        super(Typed, self).__init__()
        self.identifier=identifier
        if not hasattr(self, 'type'):
            self.type = token_type or identifier.lower().strip("'\"")

    @classmethod
    def add_callables(cls, callable_type, new_callables):
        for cl in get_subclasses(cls):
            if callable_type not in cl.__dict__:
                # The class we're dealing with doesn't have a dict for
                # this callable type, make them one
                # make sure to use the default of whatever dict they're
                # inheritting
                setattr(cl, callable_type, collections.defaultdict(
                    getattr(cl, callable_type).default_factory))
            getattr(cl, callable_type).update(new_callables)

    @classmethod
    def set_default(cls, callable_type, default):
        for cl in get_subclasses(cls):
            if callable_type not in cl.__dict__:
                # The class we're dealing with doesn't have a dict for
                # this callable type, make them one
                setattr(cl, callable_type, collections.defaultdict(lambda: default))
            else:
                # Reset the default for the callable type's dict
                getattr(cl, callable_type).default_factory = lambda: default

class Compileable(Typed):
    """
    Abstract class

    A mapping of token identifiers to functions that will compile them
    This mapping is part of the interface for the abstract Compileable, but the
    actual mappings must be provided by the compiler, NOT HERE.
    This is because this file is to be agnostic of the output format
    """
    compiles = collections.defaultdict( lambda:
        lambda self, nots=(), base_axis=None: self.identifier )

    @property
    def compile(self):
        if not hasattr( self, '_compile' ):
            self._compile = types.MethodType(
                self.compiles[self.type],
                self,
                type(self))
        return self._compile

class Interpretable(Typed):
    """
    Abstract class

    A mapping of token identifiers to functions that will interpret them
    This mapping is part of the interface for the abstract
    Interpretable, but the
    actual mappings must be provided by the interpreter, NOT HERE.
    This is because this file is to be agnostic of the output format
    """
    interprets = collections.defaultdict( lambda:
        lambda self, interpreter=None, ele=None: self.identifier )

    @property
    def interpret(self):
        if not hasattr( self, '_interpret' ):
            self._interpret = types.MethodType(
                self.interprets[self.type],
                self,
                type(self))
        return self._interpret

class Parseable(Typed):
    """
    Abstract class

    A mapping of token identifiers to functions that will run after
    This mapping is part of the interface for the abstract
    Interpretable, but the
    actual mappings must be provided by the interpreter, NOT HERE.
    This is because this file is to be agnostic of the output format
    """

    actions = collections.defaultdict( lambda:
        lambda parseable, *args, **kwargs: [] )

    def __init__(self, identifier, token_type=None):
        super(Parseable, self).__init__(
            identifier=identifier,
            token_type=token_type)
        self.error = None
        self.warnings = []

    @property
    def action(self):
        if not hasattr( self, '_action' ):
            self._action = types.MethodType(
                self.actions[self.type],
                self,
                type(self))
        return self._action

    def get_added_tokens(self):
        return []

    def parse(self, tokenstream):
        self.tokenstream = itertools.chain(tokenstream, getattr(self, 'tokenstream', []))
        while not self.done:
            try:
                token = iter(self).next()
            except StopIteration, si:
                pass
        return self.tokenstream

    @property
    def command(self):
        return self.parent.command

class Phrase(Parseable, Interpretable, Compileable):
    """
    Abstract class

    A parser that stores tokens in an internal list.
    """

    # Tokens that can be consumed by this parser
    expected=()

    # There can't be more of these tokens than listed
    cant_have = {}

    # There MUST be at least as many of these tokens as listed
    must_have = {}

    # The number of each kind of token the object has.  This will be
    # shadowed
    number_of_tokens = {}

    # The token types in this list must not be split accross the line
    must_be_together = []

    # Ways to compile this class to different results, with a default
    # Tokens that can be stored
    children=()

    def __init__(self, identifier=None, token_type=None):
        super(Phrase, self).__init__(
            identifier=identifier or 'phrase',
            token_type=token_type)
        self.children=[]
        self._last_token = None

        # Make copies of the class objects in this object
        self.expected = list(type(self).expected)
        self.number_of_tokens = dict(type(self).number_of_tokens)
        self.must_have = copy.deepcopy(type(self).must_have)
        self.cant_have = copy.deepcopy(type(self).cant_have)
        self.must_be_together = list(type(self).must_be_together)

    def __iter__(self):
        return self

    @property
    def done(self):
        done = False
        try:
            token = self.tokenstream.next()
            if token is self._last_token:
                # This is the same token we got last time, we're done
                done = True
            self.tokenstream = itertools.chain(
                [token],
                self.tokenstream)
        except StopIteration, si:
            # We couldn't find any more, we're done
            done = True
        return done

    def can_yield(self, token):
        """
        This is to test whether we'll yield this token.
        By default, never yield
        """
        return False

    def handle_end(self):
        added_stream = self.action()
        if not added_stream and self.unmet_requirements:
            # We have requirements that have not yet been
            # met, raise an exception
            raise visionexceptions.UnmetTokenRequirements(
                parser=self,
                token=self,
                tokenstream=self.tokenstream)
        return added_stream

    def next(self):
        """
        Pulls tokens out of the stream until we get a token that is not
        expected
        """
        last_token = None
        def get_next_token():
            # Gets tokens until we get a token that we don't expect
            # Then it puts the token back in the stream and finishes
            while not self.done:
                token = self.tokenstream.next()
                self._last_token = token
                if isinstance(token, tuple(self.expected)):
                    yield token
                elif token:
                    self.tokenstream = itertools.chain(
                        [token], self.tokenstream)
                    break

        token = None
        while not self.done:
            # We need to consume tokens until we're done
            for token in get_next_token():
                # We expected to see this token, consume it
                self.tokenstream = self.consume(token)
        else:
            # We're done with this token, can we yield?
            if token and self.can_yield(token):
                # We're done and this is the kind of token that we yield, do that
                return token

    def update_requirements(self, token):
        """
        Note that we've received the token if it matches any of the
        expected types.
        """
        # We iterate a copy of the list so that removing
        # items doesn't screw up our iterator
        for k in list(self.expected):
            if isinstance(token, k):
                # The token is an instance of the current key, which
                # means we need to update the number of the keys
                self.number_of_tokens[k] = self.number_of_tokens.get(k, 0) + 1
                if k in self.cant_have and self.cant_have[k] == self.number_of_tokens[k] + 1:
                    # We don't expect to see any more of this type of
                    # token.
                    self.expected.remove(k)
                    if k in self.must_be_together:
                        self.must_be_together.remove(k)

        # We iterate a copy of the list so that removing
        # items doesn't screw up our iterator
        for k in list(self.must_be_together):
            if not isinstance(token, k) and self.number_of_tokens.get(k, 0)> 0:
                # We've received tokens that must all be together, and
                # then gotten a different one.  Remove the tokens from
                # expected and from must_be_together
                self.expected.remove(k)
                self.must_be_together.remove(k)

    def adopt(self, token):
        self.children.append(token)
        token.parent=self

    def can_adopt(self, token):
        return (
            isinstance(token, tuple(type(self).children)) and
            token not in set(self.children))

    def consume(self, token, testvalue=None):
        """
        Takes a token and consumes it.  "Consuming" is fuzzy here, it is
        entirely possible that the token will be pushed back into the
        stream as part of consumtion.
        """

        self.handle_token(token, testvalue=testvalue)
        self.tokenstream = token.parse(self.tokenstream)

        # We're ending the token we're consumeing, call the handler
        # The handler might genreate new stream, so parse the
        # tokenstream it comes up with
        return token.parse(itertools.chain(
            token.handle_end(),
            self.tokenstream))

    def handle_token(self, token, testvalue=None):
        token.parser=testvalue or self.parser
        token.parent = self
        if self.can_adopt(token):
            self.adopt(token)
        self.update_requirements(token)

    @property
    def unmet_requirements(self):
        """
        A tuple of token types we don't have enough of
        """

        unmet = []
        for (need, howmany) in self.must_have.items():
            if sum(v for (have, v) in self.number_of_tokens.items() if issubclass(need,have)) < howmany:
                # We haven't met the requirements for this
                unmet.append(need)
        return tuple(unmet)

class InputPhrase(Phrase):
    """
    A Phrase that takes place inside a single input.
    """

    def __init__(self, identifier, start=0, place='selenium', token_type=None, scanner_args=None ):
        scanner_args=scanner_args or {}
        super(InputPhrase, self).__init__(
            identifier=identifier,
            token_type=token_type)
        self.phrase_start = self.keyword_start = start
        self.place=scanner_args.get('place', 'selenium')

    def __str__(self):
        return self.command.line[self.start:self.end]

    @property
    def code(self):
        return str(self)

    @property
    def start(self):
        return min([child.start for child in self.children] + [self.phrase_start])

    @property
    def end(self):
        return max([child.end for child in self.children] + [self.keyword_start + len(self.identifier)])

class Literal(InputPhrase):
    """ A literal is an arbitrary string. """

    def __init__(self, identifier, start=0, token_type=None, scanner_args=None):
        super(Literal, self).__init__(
            identifier=identifier,
            token_type=token_type,
            start=start)
        self.type = 'literal'

    def __eq__(self, other):
        return self.identifier == other.identifier

    def __str__(self):
        ident = self.identifier
        if ident and ident[0] in ("'", '"'):
            # If identifier starts with single or double quoute, remove it
            ident = ident[1:]
        if ident and ident[-1] in ("'", '"'):
            # If identifier ends with single or double quoute, remove it
            ident = ident[:-1]
        return ident

    def _compile(self):
        return self.identifier

    @property
    def compile(self, *args, **kwargs):
        return self._compile

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        self._identifier=value
        return value

class FileLiteral(Literal):
    """ A fileliteral is a literal that is gotten by openning the file named by the identifier string."""

    supported_types = {
        'text': 'create_text_file',}

    def __init__(self, identifier, start=0, token_type=None, scanner_args=None):
        super(FileLiteral, self).__init__(identifier, start, token_type=token_type, scanner_args=scanner_args)
        self.type = 'file literal'
        self.created = False
        self.directory = None
        self.abs_path = None
        self.file_content = None
        self.file_type = 'text'

    def __str__(self):
        if not self.file_content:
            if self.command.error:
                # There's an error here, don't do any opening, just
                # return the identifier
                return self.identifier

            self.open_file(
                path=self.directory or self.command.parser.interpreter.upload_dir,
                file_type="upload")
        return self.file_content or ""

    def _compile(self, *args, **kwargs):
        return "'%s'" % self

    def open_file(self, path, file_type):
        import os.path
        self.directory = path
        self.file_type = file_type
        filename = self.identifier[1:-1]
        self.abs_path = os.path.join(
            self.directory,
            filename)
        try:
            content = ""
            with open(self.abs_path, 'rb') as input_file:
                content = input_file.read()
            if not content:
                # The file was empty, raise an error
                raise visionexceptions.VisionException(
                    code=self.command.code,
                    start=self.start,
                    command=self.command,
                    message="'%s' is empty" % self.abs_path)
            self.file_content = content
        except (visionexceptions.VisionException, IOError), ioe:
            if self.command.parser.interpreter.interactivity_enabled:
                print "In '%s', could not read <%s>" % (self.command.code, self.abs_path)
                print "You can:"
                print "    (C)reate the file"
                print ( "    or (A)ccept the error." + ("  This line will be rewound and treated as an error." if
                    self.parser.scanner not in
                    (self.parser.interactive_scanner,
                    self.parser.subcommand_scanner) else ""))
                choice = raw_input("(C)reate or (A)ccept?")
                while not "accept".startswith(choice.strip().lower()):
                    if "create".startswith(choice.strip().lower()):
                        content = self.create_new_file(filename)
                        if content:
                            self.file_content = content
                            self.created = True
                            with open(self.abs_path, 'wb') as input_file:
                                input_file.write(content)
                            break
                        else:
                            print "The file cannot be empty.  If you don't want to create a file, enter (A)ccept."
                    choice = raw_input("(C)reate or (A)ccept?")

            # Either we don't allow files to be created, or the user
            # didn't want to.  Reraise
            if not self.file_content and not (self.command.skip or [scope for scope in self.command.scopes if scope.skip]):
                ve = visionexceptions.VisionException(
                    code=self.command.code,
                    start=self.start,
                    command=self.command,
                    message=str(ioe))
                ve.ioe = ioe
                raise ve

    def create_text_file(self, filename):
        # We're going to create a new file
        stopper = "<End of %s>" % filename
        content = ""
        for lineno in itertools.count(1):
            line = raw_input("Line %d of <%s>, type %s to stop input:    " % (lineno, self.abs_path, stopper))
            if line == stopper:
                break
            if content:
                content += "\n"
            content += line
        return content

    @property
    def file_type(self):
        return self._file_type

    @file_type.setter
    def file_type(self, ftype):
        ftype=ftype.lower()
        self._file_type=ftype
        self.create_new_file = getattr(
            self,
            self.supported_types.get(ftype, 'create_text_file'))
        return ftype

class Ordinal(InputPhrase):
    """ A ordinal tells which Node of a Nodeset returned by XPath to use. """

    special = '((1st)|(2nd)|(3rd)|(4th)|(5th)|(6th)|(7th)|(8th)|(9th)|(11th)|(12th)|(13th)|(14th)|(15th)|(16th)|(19th))'
    regexp = '%s|([1-9]\d*(%s|(0th)))' % (special, special)

    def __int__(self):
        val = int(re.sub(r'\D+', '', self.identifier))
        return val

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        self._identifier=value
        return value

class RelativePosition(InputPhrase):
    """
    Represents a relative postion for a Noun.

    For example:
        The table after the "Allowed Physicians" text
    """

    expected = []
    children=()
    cant_have = {}
    must_have = {}

    def action(self):
        if self.type == 'after':
            self.parent.axis = 'following-sibling::*/descendant-or-self'
        elif self.type == 'before':
            self.parent.axis = 'preceding-sibling::*/descendant-or-self'
        return []

class ValueObject(InputPhrase):
    """
    Abstract class

    A Parser Object that has a Literal value
    """

    # A ValueObject expects a Literal, or nothing
    expected=(Literal,)
    children=(Literal,)

    # A ValueObject cannot have more than one Literal
    cant_have={Literal:2}

    # This is just to tell the interface
    value_interface=Literal

    # Ways to compile this class to different results, with a default
    compiles = collections.defaultdict( lambda:
        lambda valueobject, *args, **kwargs:
            "%s(%s)" % (
                valueobject.identifier,
                valueobject.value_interface.compile() if valueobject.value_interface else ""))
    actions = collections.defaultdict(
        lambda: lambda action, *args, **kwargs: [] )
    interprets = collections.defaultdict(
        lambda: lambda interpret, *args, **kwargs: None )

    def __init__(self, identifier, start, token_type=None, scanner_args=None):
        scanner_args = scanner_args or {}
        # Use those arguments to call super
        super(ValueObject, self).__init__(
            identifier=identifier,
            start=start,
            token_type=token_type,
            scanner_args=scanner_args)

        # Get more arguments from the scanner
        cant_have=scanner_args.get('cant_have', {})
        must_have=scanner_args.get('must_have', {})
        self.cant_have = copy.deepcopy(self.cant_have)
        self.must_have = copy.deepcopy(self.must_have)
        if not hasattr(cant_have, 'keys'):
            # It's not mapping, make it one
            cant_have = dict((x, 1) for x in cant_have)
        if not hasattr(must_have, 'keys'):
            # It's not mapping, make it one
            must_have = dict((x, 1) for x in must_have)

        # requirements given here override those of the class
        self.cant_have.update(cant_have)
        self.must_have.update(must_have)
        for t in self.must_have:
            if t not in self.expected:
                self.expected.append(t)

        for t in self.cant_have:
            if t not in self.expected and self.cant_have[t] > 1:
                # If we cant_have 2, we can have 1, so it must be
                # expected
                self.expected.append(t)

    def compile(self):
        if not hasattr( self, '_compile' ):
            self._compile = types.MethodType(
                self.compiles[self.type],
                self,
                type(self))
        return self._compile()

    @property
    def value(self):
        try:
            return itertools.ifilter(
                lambda child: isinstance(child, Literal),
                self.children).next()
        except StopIteration, si:
            return None

    @property
    def values(self):
        return tuple(itertools.ifilter(
            lambda child: isinstance(child, Literal),
            self.children))

class FilteredValueObject(ValueObject):
    """
    A ValueObject that can provide info on how to filter elements
    """

    def __init__(self, identifier, start, cant_have=(), token_type=None, scanner_args=None):
        scanner_args = scanner_args or {}
        super(FilteredValueObject, self).__init__(
            identifier,
            start,
            token_type=token_type,
            scanner_args=scanner_args)
        self.filters = scanner_args.get('filters', [])

class Noun(FilteredValueObject):
    """
    Represents a Noun.
    """

    # Nouns have methods that indicate contents of the element
    contents=collections.defaultdict()

    # A Noun expects a Literal, Ordinal, or RelativePosition
    expected=(Literal,Ordinal,RelativePosition)
    children=(Literal,Ordinal,RelativePosition)

    # A Noun cannot have more than one Literal or Ordinal
    cant_have={
        RelativePosition:2,
        Literal:2,
        Ordinal:2}

    # When we interpret this, we'll base our search on the previous
    # context.  Setting this to False will tell the interpreter not to
    # go further up the context stack, since we always base the search
    # on the root

    # Testing if the noun is ready to be used to find sub-widgets
    # By default, they are ready
    readies = collections.defaultdict(
        lambda: lambda self, interpreter, ele: True)

    def __init__(self, identifier, start, token_type=None, scanner_args=None):
        scanner_args = scanner_args or {}
        super(Noun, self).__init__(
            identifier,
            start,
            token_type=token_type,
            scanner_args=scanner_args)
        self._element = None
        self.id = None
        self.timing = collections.OrderedDict()
        self.axis = 'descendant'
        self.use_parent_context_for_interpretation = scanner_args.get('use_parent_context_for_interpretation', True)
        self.window_handle = None

    @property
    def cached(self):
        if getattr(self, 'element', None):
            try:
                return self.element.tag_name and self.element.is_displayed()
            except StaleElementReferenceException, sere:
                return False
            except AttributeError as ae:
                return True
        return False

    @property
    def element(self):
        return self._element

    @element.setter
    def element(self, el):
        if self.command.check_readyState and not self.window_handle:
            # Get the current window handle, so that later we can
            # compare to make sure we're in the right window
            self.window_handle = self.command.parser.interpreter.webdriver.current_window_handle
        self._element = el
        el.noun = self
        return el

    @element.deleter
    def element(self):
        # Remove the cached element and id
        del self._element
        if hasattr(self, 'id'):
            del self.id

    @property
    def ordinal(self):
        return int(self.ordinal_word)

    @property
    def ordinal_word(self):
        return itertools.ifilter(
            lambda tok: isinstance(tok, Ordinal),
            itertools.chain(
                self.children,
                [Ordinal(identifier="1st")])).next()

    @property
    def ready(self):
        interpreter = self.parser.interpreter
        return self.readies[self.type](
            self=self,
            interpreter=interpreter,
            ele=self.element)

    @property
    def content(self):
        return self.contents[self.type](self)

    @property
    def xpath(self):
        # Find the absolute xpath to the element for this node from the
        # most recent ancestor with an id, or the root.  returns None
        # there's no element cached
        js_code = """
            var node = arguments[0];
            var path = "";
            while (node) {
                var node_id = node.getAttribute('id');
                if (node_id) {
                    path = "/" + node.tagName + "[@id='" + node_id + "']" + path;

                    // We've found an id, we can stop
                    break;
                } else {
                    path = "/" + node.tagName + path;
                }
                node = node.parentElement;
            }

            if (node) {
                // We broke, so this node is not necesarily the root,
                // add a slash to the path
                path = "/" + path;
            }

            return path;
        """
        try:
            return self.parser.interpreter.webdriver.execute_script(js_code, self.element)
        except:
            return None

class AttributeNoun(Noun):
    """
    Represents a Noun that was described by HTML attribute or XPATH
    """

    # An AttributeNoun expects an Ordinal
    expected=(Ordinal,)
    children=(Ordinal,)

    # An AttributeNoun cannot have more than one Ordinal
    cant_have={
        Ordinal:2}

    interprets = collections.defaultdict(
        lambda: lambda interpret, *args, **kwargs: None )

    def __init__(self, identifier, start, token_type=None, scanner_args=None):
        scanner_args = scanner_args or {}
        super(AttributeNoun, self).__init__(
            'attributenoun',
            start,
            token_type=token_type,
            scanner_args=scanner_args)

        method, means = identifier[1:-1].split("=", 1)
        method = method.lower()
        self.method, self.means = method, means
        if self.method == 'id':
            self.id = self.means

    @property
    def identifier(self):
        return self._identifier

    @identifier.setter
    def identifier(self, value):
        self._identifier='attributenoun'
        return value

    @property
    def end(self):
        return max(
            [child.end for child in self.children] + [self.keyword_start + len("{" + self.method + "=" + self.means + "}")])

    def compile(self, *args, **kwargs):
        xpath = self.means
        if self.method != 'xpath':
            xpath = "//node()[@%s='%s']" % (self.method, self.means)
        return (xpath,), ()

class Context(ValueObject):
    """
    Represents Context of a command.
    """
    compiles = ValueObject.compiles.copy()
    actions = ValueObject.actions.copy()
    interprets = ValueObject.interprets.copy()

    @property
    def referent(self):
        scope = 0
        min_scope = 0
        for command in self.command.commands_in_scope_iter:
            if command.variable and str(command.variable.value) == str(self.value):
                # This command defines the variable we use for
                # context, get its subject
                return command.subject
        else:
            # we're using a context that is undefined, raise an exception
            raise visionexceptions.UndeclaredContextError(command=command)

class SubjectPartStart(InputPhrase):
    expected = [Literal, Ordinal, Noun, Context]
    children=(Literal,Ordinal)
    cant_have = {
        Literal:2,
        Ordinal:2,
        Noun:2,
        Context:2 }
    must_have = {
        Noun:1,
        Context:1}

    def parse(self, *args):
        return super(SubjectPartStart, self).parse(*args)

    def consume(self, token):
        # If token is a Noun, push it, and any children we've gotten,
        # back on to the stream and change it's phrase_start to the
        # start of this token.
        # The next time around, this'll fail the requirement of not
        # getting more than 1 Noun, and it will return parsing control
        # to the Command
        if isinstance(token, (Noun, Context)):
            del self.must_have[Context]
            del self.must_have[Noun]
            self.tokenstream = itertools.chain(
                [token] + self.children,
                self.tokenstream)
            token.phrase_start = self.start
            return self.tokenstream
        return super(SubjectPartStart, self).consume(token)

class ScopeChange(InputPhrase):
    """
    Marks the scope a line is on, one of these for each level of scope.
    """
    pass

class Subject(Compileable, Interpretable):
    """
    Represents a group of Nouns forming a locator.
    This is purely a convenient way to bundle up the tuple of Nouns in a
    command so that I can attach convenience methods to them.
    """

    # Ways to compile this class to different results, with a default
    compiles = collections.defaultdict( lambda:
        lambda subject, *args, **kwargs: " ".join(n.compile() for n in subject.nouns))
    interprets = collections.defaultdict( lambda:
        lambda subject, *args, **kwargs: " ".join(n.compile() for n in subject.nouns))
    actions = ValueObject.actions.copy()

    def __init__(self, command, context, nouns, token_type=None):
        self.command = command
        self.context = context
        self.nouns = nouns
        self.id = None
        self.timing = collections.OrderedDict()
        typ = 'subject'
        try:
            typ = next(self.all_nouns).type
        except StopIteration, si:
            pass

        super(Subject, self).__init__(
            identifier='subject',
            token_type=typ)

    def __str__(self):
        nouns = list(self.all_nouns if self.command.error else self.window_context_nouns)
        return ' in '.join(noun.code for noun in nouns)

    def compile(self):
        if not hasattr( self, '_compile' ):
            self._compile = types.MethodType(
                self.compiles[self.type],
                self,
                type(self))
        return self._compile()

    def get_context_nouns(self, get_compare_handle=lambda driver:driver.current_window_handle):
        # Returns and iteratory of all nouns in the scope until we hit a
        # noun that is from a different window
        def handle_nouns(nouns):
            for noun in nouns:
                compare_handle = None
                if self.command.check_readyState and noun.window_handle:
                    compare_handle = get_compare_handle(self.command.parser.interpreter.webdriver)
                if compare_handle and noun.window_handle != compare_handle:
                    # This noun is in the wrong window, there's no point
                    # in looking at the rest of the context
                    raise StopIteration()
                else:
                    yield noun
                if not noun.use_parent_context_for_interpretation:
                    raise StopIteration()

        return handle_nouns(self.all_nouns)

    @property
    def all_nouns(self):
        # Iterator of all nouns in the context of the subject
        # This does not take into account what window the noun is in
        for noun in self.nouns:
            yield noun
        if self.context:
            for noun in self.context.all_nouns:
                yield noun

    @property
    def window_context_nouns(self):
        # Iterator of nouns that are in the context of this subject and
        # in the same window
        return self.get_context_nouns()

    @property
    def code(self):
        noun_getter = self.all_nouns
        if not self.command.error:
            # If there's not an error, we want to see all the nouns in
            # the window
            noun_getter = self.get_context_nouns(
                get_compare_handle=lambda driver:self.command.window_handle)
        return ' in '.join(list(
            noun.code for noun in noun_getter))

    @property
    def end(self):
        return max(noun.end for noun in self.nouns)

    @property
    def start(self):
        return min(noun.start for noun in self.nouns)

    @property
    def type(self):
        try:
            return next(self.all_nouns).type
        except StopIteration as si:
            return 'subject'

class Verb(FilteredValueObject):
    """
    Represents a Verb.  This doesn't behave any differently from any
    other ValueObject, but it is treated differently by the parser.
    """
    compiles = ValueObject.compiles.copy()
    actions = ValueObject.actions.copy()
    interprets = ValueObject.interprets.copy()

    def __init__(self, identifier, start, token_type=None, scanner_args=None):
        scanner_args=scanner_args or {}
        super(Verb, self).__init__(identifier, start, token_type=token_type, scanner_args=scanner_args)
        self.timed=scanner_args.get('timed', True)

    @property
    def interpret(self):
        return types.MethodType(
            self.interprets[self.type][self.command.subject.type if self.command.subject else None],
            self,
            type(self))

    @property
    def usable(self):
        return not self.error or (not self.parser.interpreter.interactivity_enabled and self.type in ('require', 'test', 'validate'))

    @classmethod
    def add_callables(cls, callable_type, new_callables):
        if callable_type == 'interprets':
            # Verb interpret functions get special treatment, because a
            # Verb can have different interpretations based on its noun
            for cl in get_subclasses(cls):
                if callable_type not in cl.__dict__:
                    # The class we're dealing with doesn't have a dict for
                    # this callable type, make them one
                    # make sure to use the default of whatever dict they're
                    # inheritting
                    setattr(cl, callable_type, collections.defaultdict(
                        lambda: collections.defaultdict(
                            getattr(
                                cl,
                                callable_type,
                                collections.defaultdict(lambda *args, **kwargs: None)
                            ).default_factory)))
                getattr(cl, callable_type).update(new_callables)
        else:
            super(Verb, cls).add_callables(callable_type, new_callables)

    @classmethod
    def set_default(cls, callable_type, default):
        if callable_type == 'interprets':
            # Verb interpret functions get special treatment, because a
            # Verb can have different interpretations based on its noun
            for cl in get_subclasses(cls):
                if callable_type not in cl.__dict__:
                    # The class we're dealing with doesn't have a dict for
                    # this callable type, make them one
                    setattr(cl, callable_type, collections.defaultdict(lambda: default))
                else:
                    # Reset the default for the callable type's dict
                    getattr(cl, callable_type).default_factory = lambda: default
        else:
            super(Verb, cls).set_default(callable_type, default)

class InterpreterVerb(Verb):
    """
    This is a Verb that is specific to the interpreter.  It doesn't
    behave any differently from other Verbs, but is treated differently.
    """
    yieldable = False

    compiles = Verb.compiles.copy()
    actions = Verb.actions.copy()
    interprets = Verb.interprets.copy()

    @property
    def usable(self):
        return self.command.type == 'scope'

    @property
    def interpret(self):
        return types.MethodType(
            self.interprets[self.type][None],
            self,
            type(self))

class OrdinalVerb(Verb):
    """
    The OrdinalVerb verb is for dropdown-like things that might have more
    than one identical value.

    Example:

        Select the 2nd "Fred" from the "Name" dropdown
    """

    expected = (Literal, Ordinal)
    children = (Literal, Ordinal)

    @property
    def ordinal(self):
        return itertools.chain(
            itertools.imap(
                lambda ord: int(ord),
                itertools.ifilter(
                    lambda tok: isinstance(tok, Ordinal),
                    self.children)),
            [1]).next()

class Noop(Verb):
    """
    Represents a Noop.
    """
    pass

class Variable(ValueObject):
    """
    Represents naming of the target in the scope.  This doesn't behave
    any differently from any other ValueObject, but it is treated
    differently by the parser.
    """
    compiles = ValueObject.compiles.copy()
    actions = ValueObject.actions.copy()
    interprets = ValueObject.interprets.copy()

class CommandModifier(ValueObject):
    """
    A CommandModifier changes how the interpreter treats the command it
    is a part of without changing the structure of the subject or the
    meaning of the Verb.
    """

class Comment(CommandModifier):
    """
    Represents a comment.
    """

    # A Comment expects a Literal
    expected=(Literal,)
    children=(Literal,)

    # A Comment cannot have more than one Literal
    cant_have={Literal:2,}

class TemplateInjector(CommandModifier):
    """
    Loads a template into a 'Template Section' or 'Data Section's
    template variable
    """
    # A TemplateInjector expects a Literal
    expected=(Literal,)
    children=(Literal,)

    must_have={Literal:1,}

class Wait(CommandModifier):
    """
    Represents the ammount of time the command must be completed within.
    """

    # A Wait expects a Literal
    expected=(Literal,)
    children=(Literal,)

    # A Wait cannot have more than one Literal
    cant_have={Literal:2,}

class Skip(InputPhrase):
    """
    Represents the reason the command will be skipped.  Skipped comands
    are treated as errors, but do not stop execution of subsequent
    commands.

    Subcommands of Skipped sections are not executed.
    """

    expected=()
    children=()

class Command(InputPhrase):
    """
    A command corresponds the active part of a line of code
    """

    # A command can have Objects, Subjects, and Verbs, in any order
    # It can only have one of each kind of clause
    expected=(Context, Noun, Verb, Variable, Noop, Comment, Wait, Skip, SubjectPartStart)
    children=(Context, Noun, Verb, Variable, Comment, Wait, Skip)
    must_have={Verb: 1}
    cant_have={
        Wait: 2,
        Skip: 2,
        Verb: 2,
        Variable:2 }
    yieldable = True

    def __init__(self, scanner, lineno, token_type=None, scanner_args=None):
        self.scopechange = 0
        self.lineno = lineno
        self.origin_scanner = self.scanner = scanner
        self.trace = None
        self.error = None
        self.executed = False
        self.subcommands = False
        self.parser = scanner.parser
        self.run_after_error = False
        self.parsed = False
        self.check_readyState = True
        self.window_handle = None
        self.uses_elements = True
        self.dont_verb = False

        super(Command, self).__init__(
            identifier='command',
            token_type='selenium',
            scanner_args=scanner_args or {})

    def get_variable_from_scope(self, var):
        # var is a string that is the name of the variable
        current_level = 0
        min_level = 0
        for command in self.previous_usable_commands_iter:
            current_level -= command.scopechange
            if current_level <= min_level:
                # We only look at commands in scopes that are in the
                # minimum level or below.  This ensures we are always in
                # scope
                min_level = current_level
                if command.variable and str(command.variable.value) == var:
                    return command.subject

        # This should have an exception, I think
        raise visionexceptions.UndeclaredContextError(command=self)

    def compile(self):
        comps = []
        for c in self:
            comps.append(c.compile())
        return ' '.join(comps)

    def handle_end(self):
        try:
            tok = next(self.tokenstream)

            # At this point, we've finished parsing the Command but have
            # tokens left to consume.  raise an error
            self.tokenstream = itertools.chain(
                [tok],
                self.tokenstream)
            raise visionexceptions.TooManyTokens(
                command=self,
                tokenstream=self.tokenstream)
        except StopIteration, si:
            # There were no leftover tokens, this is good
            # Swallow the exception
            pass
        return super(Command, self).handle_end()

    def parse(self, tokenstream):
        """
        Consume enough for a single command
        """
        stream = [t for t in tokenstream]
        self.tokens = getattr(self, 'tokens', stream)
        self.tokenstream = iter(stream)
        while not self.done:
            token = iter(self).next()
        self.parsed = True
        return self.tokenstream

    @property
    def comment(self):
        comment_iter = itertools.ifilter(
            lambda token: isinstance(token, Comment),
            self.children)
        try:
            return next(comment_iter)
        except StopIteration, si:
            return None

    @property
    def code(self):
        code = self.scanner.lines[self.lineno - 1].strip()
        if self.comment:
            code = ' '.join([
                code[:self.comment.start],
                code[self.comment.end:]])
        return code

    @property
    def line(self):
        try:
            return self.scanner.lines[self.lineno - 1]['code'].strip()
        except TypeError as te:
            return self.scanner.lines[self.lineno - 1].strip()
        except:
            raise

    @property
    def command(self):
        return self

    @property
    def context(self):
        if not hasattr( self, "_context"):
            for child in self.children:
                if isinstance(child, Context):
                    # If we have a context defined return it
                    if str(child.value) == 'global':
                        # If we're looking in the 'global' context, then
                        # we don't want to return one here
                        self._context = None
                    else:
                        try:
                            self._context = child.referent
                        except visionexceptions.UndeclaredContextError as uce:
                            # The referent was never actually defined...
                            # We'll pass this, and they'll get a none
                            # for the context
                            pass

                    # We've found the context, break out
                    break
            else:
                # Search for context in scope
                try:
                    scope = next(s for s in self.scope_iter if not (s.error or s.skip))
                    if scope.subject:
                        self._context = scope.subject
                    else:
                        self._context = scope.context
                except StopIteration, si:
                    # If there's no scopes, then eat this
                    pass
        return getattr(self, '_context', None)

    @property
    def commands_in_scope_iter(self):
        """
        Gets commands that are in scope for this command.
        """
        def scope_gen():
            scope_level = 0
            min_scope = 0
            for command in itertools.ifilter(
              lambda com: not (com.error or com.skip),
              self.previous_commands_iter):
                scope_level -= command.scopechange
                if scope_level <= min_scope:
                    min_scope = scope_level
                    yield command

        return scope_gen()

    @property
    def end(self):
        return -1

    @property
    def expected_scope_level(self):
        level = 0
        prev_command = None
        for command in reversed(list(self.previous_usable_commands_iter)):
            if prev_command:
                level += command.scope_level - prev_command.scope_level
        return level

    @property
    def filename(self):
        return self.scanner.name

    @property
    def previous_commands_iter(self):
        """
        Returns an iterator over all commands before the current one,
        in LIFO order.

        This is for internal use, so that we can use itertools for other
        things without actualizing the iterator at the beginning.
        """
        prev_iter = reversed(self.parser.children)
        if self in self.parser.children:
            prev_iter = itertools.ifilter(
                lambda token: token is not self,
                itertools.dropwhile(
                    lambda token:token is not self,
                    reversed(self.parser.children)))
        return prev_iter

    @property
    def previous_usable_commands_iter(self):
        """
        Returns an iterator over all commands before the current one,
        in LIFO order.

        This is for internal use, so that we can use itertools for other
        things without actualizing the iterator at the beginning.
        """
        prev_iter = itertools.ifilter(
            lambda command: command.usable,
            self.previous_commands_iter)
        return prev_iter

    @property
    def previous_commands(self):
        """
        Gets a tuple from previous_usable_commands_iter, for external use
        """
        return tuple(self.previous_usable_commands_iter)

    @property
    def scope_iter(self):
        def gen_scopes():
            base_scope = scope_level = -1 * self.scopechange

            for command in self.previous_commands_iter:
                if command.usable and command.scopechange:
                    # This way we take "End test" commands in account
                    # when we count what scope we're in
                    scope_level -= command.scopechange
                    if scope_level < base_scope:
                        base_scope = scope_level
                        yield command
        return gen_scopes()

    @property
    def scopes(self):
        return tuple(reversed(tuple(self.scope_iter)))

    @property
    def usable(self):
        return self.verb and self.verb.usable

    @property
    def scope_level(self):
        return self.parser.get_scope_difference(to=self)

    @property
    def subject(self):
        if not hasattr(self, "_subject"):
            context = self.context
            nouns = list(token for token in self.children if isinstance(token, Noun))
            if nouns or context:
                self._subject = Subject(
                    command=self,
                    nouns=nouns,
                    context=context)
        return getattr(self, '_subject', None)

    @property
    def variable(self):
        var = None
        variables_iter = itertools.ifilter(lambda token:isinstance(token, Variable), self.children)
        try:
            var = next(variables_iter)
        except StopIteration, si:
            var = None
        return var

    @property
    def variables_in_scope(self):
        variables = {}
        for c in itertools.ifilter(lambda command:command.variable, reversed(self.scopes)):
            variables[c.variable.value.identifier] = c.subject

        return variables

    @property
    def verb(self):
        verbs_iter = itertools.ifilter(
            lambda token: isinstance(token, Verb),
            self.children)
        try:
            return next(verbs_iter)
        except StopIteration, si:
            return None

    @property
    def wait(self):
        wait_iter = itertools.ifilter(
            lambda token: isinstance(token, Wait),
            self.children)
        try:
            return int(str(next(wait_iter).value))
        except StopIteration, si:
            return self.parser.interpreter.maximum_wait

    @property
    def skip(self):
        skip_iter = itertools.ifilter(
            lambda token: isinstance(token, Skip),
            self.children)
        try:
            return next(skip_iter)
        except StopIteration, si:
            return None

    @skip.setter
    def skip(self, literal):
        if self.skip:
            raise Exception("Already skipped")
        else:
            self.parse([
                Skip(identifier='is skipped', start=0),
                Comment(identifier='because', start=0),
                Literal(literal, start=0)])

    def adopt(self, token):
        adopt_ret = super(Command, self).adopt(token)
        if hasattr(self, "_subject"):
            # If we already have a subject, get rid of it, because it
            # doesn't know about what we just adopted.
            del self._subject

class InterpreterCommand(Command):
    """
    This is a Command that doesn't consider commands that were errors or
    removed in its history.  It will not be saved out to the file if the
    test is saved, and it ignores whether the current scope is being skipped.
    """

    def __init__(self, scanner, lineno):
        super(InterpreterCommand, self).__init__(scanner, lineno)
        self.removed = False
        self.error = False
        self.vision_saved = []
        self.scopechange = 0
        self.timing = collections.OrderedDict()

        # By default, we assume a command exists because it was found in
        # its scanner, but scope ending commands can originate with
        # another scanner if they were injected as a result of a closing
        # scope.  Default to being scanner; the scanner will change it if
        # necessary
        self.origin_scanner = scanner

    def can_adopt(self, token):
        return super(InterpreterCommand, self).can_adopt(token) and getattr(token, 'adoptable', True)

    @property
    def code(self):
        line = self.scanner.lines[self.lineno - 1]
        try:
            return line['code'].strip()
        except TypeError as te:
            return line.strip()

class VisionParser(Phrase):
    """
    This the parser for Vision.  It is iterable, and returns one command
    (line) at a time.
    """

    # A command can have Objects, Subjects, and Verbs, in any order
    # It can only have one of each kind of clause
    expected=(Command,)
    children=(Command,)

    must_have={
        Command: 1, }

    def __init__(self, scanner):
        super(VisionParser, self).__init__()
        self.scanner = scanner

    def adopt(self, token):
        try:
            return super(VisionParser, self).adopt(token)
        finally:
            token.parsed = True

    def can_yield(self, token):
        return isinstance(token, Command) and token.yieldable

    def compile(self):
        comps = []
        for c in self:
            comps.append(c.compile())
        return ''.join(comps)

    def consume(self, token):
        return super(VisionParser, self).consume(token, self)

    def get_scope_difference(self, to=None, fro=None):
        to = to if to else self.children[-1]
        fro = fro if fro else self.children[0]
        scopechange = 0

        commands = itertools.ifilter(
            lambda com: com.usable,
            itertools.takewhile(
                lambda com: com is not to,
                itertools.dropwhile(
                    lambda com: com is not fro,
                    self.children)))
        for command in commands:
            scopechange += command.scopechange
        return scopechange

    def next(self):
        if not self.scanner:
            raise StopIteration()
        tokens = self.scanner.next()
        self.tokenstream = iter(tokens)
        return super(VisionParser, self).next()

    @property
    def scopes(self):
        level = 0
        scopes = []
        for com in self.children:
            if com.usable:
                level += com.scopechange
                if com.verb.type in ('require', 'test', 'validate'):
                    scopes.append(com)
        return scopes

    @property
    def scope_level(self):
        return self.get_scope_difference()

    @property
    def number_of_lines(self):
        return len(self.children)

